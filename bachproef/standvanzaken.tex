\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

In dit hoofdstuk wordt de theoretische basis gelegd voor het verdere onderzoek. 
Er wordt gestart met een verkenning van de mainframe-sector en de de rol die COBOL daarin speelt

% ----------------------------------------------------------------------------------------------------- %
\section{De Mainframe Wereld: Kritieke Infrastructuur in Transitie}
\label{sec:mainframe-wereld}

\subsection{Het platform achter de code}

Om de context waarin een junior COBOL-developer terechtkomt te kaderen, is het essentieel om eerst het mainframe-platform te definiëren. 
Volgens de definitie van \textcite{IBM2010} is een mainframe een server die door bedrijven wordt gebruikt om commerciële databases, transactieservers en applicaties te hosten die een hogere mate van beveiliging en beschikbaarheid vereisen dan doorgaans beschikbaar is op kleinere machines.

Deze servers draaien op gespecialiseerde besturingssystemen zoals z/OS (IBM) of ClearPath MCP (Unisys).
De hardware en software zijn inherent ontworpen met de strenge eisen van een enterprise-omgeving in gedachten, vaak samengevat onder de noemer \textbf{RAS} \autocite{Ebbers2011}:

\begin{itemize}
  \item \textbf{Betrouwbaarheid (Reliability):} Zelfherstellende hardware en uitgebreid geteste software minimaliseren de kans op systeemfouten.
  \item \textbf{Beschikbaarheid (Availability):} Het systeem kan herstellen van defecten zonder downtime, wat cruciaal is voor 24/7 dienstverlening.
  \item \textbf{Onderhoudsvriendelijkheid (Serviceability):} Snelle foutdetectie en diagnose maken efficiënt beheer mogelijk.
\end{itemize}

Naast de RAS-kenmerken is \textbf{blijvende compatibiliteit} een cruciale pijler: het unieke vermogen om applicaties die decennia geleden zijn geschreven (vaak in COBOL), zonder grote wijzigingen te kunnen blijven draaien op de nieuwste generaties hardware.

Hoewel critici in de jaren '90, zoals Stewart Alsop, voorspelden dat de laatste mainframe in 1996 zou worden uitgeschakeld \autocite{Alsop1991}, vormt het platform vandaag de dag nog steeds de onzichtbare ruggengraat van de wereldeconomie.

\subsection{De blijvende relevantie van COBOL}

De gebruikers van mainframes bevinden zich in sectoren waar de verwerking van enorme transactievolumes en extreme betrouwbaarheid cruciaal zijn. 
De programmeertaal COBOL (\textit{Common Business Oriented Language}), waarvan de eerste versie in 1960 werd gelanceerd, is hierbij de standaard. 
Ondanks de leeftijd van de taal, wordt de hoeveelheid COBOL-code in actieve productieomgevingen momenteel geschat op 250 miljard regels \autocite{IBM2025}.

Deze enorme codebase vormt de basis voor kritieke sectoren zoals:
\begin{itemize}
      \item \textbf{Financiële instellingen:} Mainframes verwerken naar schatting 85\% van het wereldwijde betalingsverkeer. 45 van de top 50 banken, waaronder instellingen zoals ING en de ECB, maken gebruik van deze systemen \autocite{IBM2022a}.
      \item \textbf{Overheid en Zorg:} Cruciale diensten zoals pensioenuitbetalingen, belastinginning en de beveiliging van patiëntgegevens rusten op COBOL-applicaties die door de jaren heen zijn geoptimaliseerd \autocite{IBM2022}.
      \item \textbf{Retail en Logistiek:} Grote retailers en logistieke bedrijven vertrouwen op de ongeëvenaarde verwerkingskracht voor voorraadbeheer en transactieverwerking op globale schaal.
\end{itemize}

De marktwaarde onderstreept deze relevantie: in 2022 werd de mainframemarkt geschat op 2,9 miljard dollar, met een verwachte groei naar 5,6 miljard dollar in 2032 \autocite{Allied2022}. 
Dat COBOL-systemen de ruggengraat van de wereldeconomie blijven vormen, wordt bevestigd door het feit dat ze bijna 70\% van de wereldwijde IT-workloads voor productie verwerken \autocite{Granger2021}.


\subsection{De generatieshift en de kenniskloof}

Hoewel het mainframe een bewezen technologie is die al decennia lang ondernemingen ondersteunt, vindt er momenteel een fundamentele verschuiving plaats in wie dit platform beheert. 
Waar de systemen voorheen het domein waren van de 'Baby Boomer'-generatie, is de langverwachte generatiewissel nu een feit. 
Uit recent onderzoek van \autocite{BMC2025} blijkt dat inmiddels 66\% van de mainframe-professionals tot de Millennials of Generatie Z behoort, terwijl het aandeel Boomers en Gen X is gekrompen tot minder dan de helft.

Deze verschuiving brengt echter een kritieke uitdaging met zich mee: een groeiend tekort aan expertise. Terwijl ervaren COBOL-specialisten met pensioen gaan, worden de huidige softwareontwikkelaars voornamelijk opgeleid in moderne programmeertalen \autocite{IBM2025}. 
Dit creëert een kloof op de arbeidsmarkt, waarbij er steeds minder programmeurs beschikbaar zijn die de complexe COBOL-applicaties kunnen beheren en updaten \autocite{IBM2025}.
Voor een junior developer betekent dit niet alleen een taalkundige barrière, maar ook een verschuiving in de manier waarop zij met legacy-systemen moeten omgaan.

% TODO: dit past misschien beter bij probleemstelling
De noodzaak om deze nieuwe generatie aan te trekken en op te leiden is zichtbaar in de bedrijfsstrategieën. 
80\% van de bedrijven heeft in 2025 hun mainframe-strategie aangepast met het oog op modernisering \autocite{Kyndryl2025}. 
Van deze projecten is slechts 16\% gericht op het verlaten van het platform; de meerderheid kiest voor integratie met de cloud (34\%) of modernisering op het mainframe zelf (43\%) \autocite{Kyndryl2025}.
Deze cijfers onderstrepen dat COBOL-expertise cruciaal blijft, maar dat de methode waarop deze kennis wordt overgedragen aan de nieuwe generatie developers moet evolueren.

% ----------------------------------------------------------------------------------------------------- %
\section{COBOL versus Python}
\label{sec:COBOL-versus-python}

TODO: korte inleiding

\subsection{Programmastructuur}
In tegenstelling tot Python-scripts, die vaak top-down worden uitgevoerd, volgt een COBOL-programma een strak gedefinieerde structuur. \autocite{TutorialsPoint}

\begin{figure}[H]
\centering
\begin{minipage}{0.45\textwidth}
  \begin{itemize}
    \item \textbf{Divisions:} De logische onderverdeling van de programmalogica. Een sectie is een verzameling van paragrafen.
    \item \textbf{Paragraphs:} De onderverdeling van een sectie of divisie. Het is een door de gebruiker gedefinieerde of vooraf gedefinieerde naam gevolgd door een punt, en bestaat uit nul of meer zinnen.
    \item \textbf{Sentences:} De combinatie van een of meer uitspraken. Zinnen komen alleen voor in de \textit{Procedure Division}. Een zin moet eindigen met een punt.
    \item \textbf{Statements:} zinvolle COBOL-instructies die bepaalde bewerkingen uitvoeren.
  \end{itemize}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
  \centering
  \includegraphics[width=\linewidth]{program_structure_COBOL.jpg}
  \caption{Programmastructuur COBOL \autocite{TutorialsPoint}}
  \label{fig:program_structure_COBOL_jpg}
\end{minipage}

\end{figure}

Een COBOL programma bestaat uit 4 \textit{Divisions}: \autocite{IBMMainframer2021}

\begin{itemize}
    \item \textbf{IDENTIFICATION DIVISION:} Bevat de metadata. Het is de enige verplichte divisie waarin de \texttt{PROGRAM-ID} wordt gedefinieerd.
    Dit fungeert als de unieke naam waarmee het programma door het besturingssysteem (zoals z/OS) wordt aangeroepen.
    \item \textbf{ENVIRONMENT DIVISION:} Hier vindt de koppeling plaats tussen de logische programmastructuur en de fysieke hardware. In de \texttt{INPUT-OUTPUT SECTION} worden fysieke datasets (bestanden) gekoppeld aan interne namen. In Python gebeurt dit dynamisch via variabelen, maar in COBOL is dit een statische configuratie.
    \item \textbf{DATA DIVISION:} De meest omvangrijke sectie voor databeheer. Hieronder valt de \texttt{WORKING-STORAGE SECTION}, waar elke variabele die het programma gebruikt, vooraf moet worden gealloceerd. COBOL kent geen \textit{garbage collection} of dynamische geheugenallocatie zoals Python \autocite{Ebbers2011}.
    \item \textbf{PROCEDURE DIVISION:} De plaats waar de executabele algoritmen staan. Deze is onderverdeeld in \textit{Paragraphs} en \textit{Sections}, die dienen als de primaire eenheden voor logische groepering, bij gebrek aan native functies of klasses in de basisstructuur.
\end{itemize}

\subsection{Datatypen en de PICTURE-clausule}
In Python is een variabele een referentie naar een object in het geheugen. 
In COBOL is een variabele een directe definitie van een reeks bytes. 
De \texttt{PICTURE}-clausule (\texttt{PIC}) bepaalt hoe deze bytes geïnterpreteerd moeten worden \autocite{IBM2023}.

\subsubsection{De PIC-symbolen}

De meest voorkomende symbolen in een \texttt{PIC}-clausule zijn:
\begin{itemize}
    \item \textbf{\texttt{9}} (Numeriek): Representeert exact één cijfer (0-9).
    \item \textbf{\texttt{X}} (Alfanumeriek): Representeert elk karakter (letter, cijfer, symbool).
    \item \textbf{\texttt{A}} (Alfabetisch): Enkel letters en spaties.
    \item \textbf{\texttt{V}} (Impliciet decimaalteken): Geeft de positie van de komma aan zonder een fysieke byte te gebruiken. Dit is essentieel voor financiële berekeningen op mainframes.
    \item \textbf{\texttt{S}} (Sign): Geeft aan dat een numeriek veld een positief of negatief teken kan bevatten.
\end{itemize}

\begin{table}[h!]
    \centering
    \caption{Vergelijking van datadefinities}
    \label{tab:pic-vergelijking}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Type} & \textbf{COBOL Definitie} & \textbf{Python Equivalent} \\ \hline
        Integer & \texttt{05 AGE PIC 9(05) VALUE 12345} & \texttt{age = 12345} \\ \hline
        String & \texttt{05 NAME PIC X(10) VALUE 'JOS'} & \texttt{name = "Jos"} \\ \hline
        Decimal & \texttt{05 PRICE PIC S9(5)V99 VALUE -123.45} & \texttt{price = -123.45} \\ \hline
    \end{tabular}
\end{table}

De \texttt{PIC}- of \texttt{PICTURE}-clausule kan ook worden geschreven zonder de \texttt{VALUE}-clausule. 
In dat geval wordt de variabele automatisch geïnitialiseerd met de standaardwaarde van het opgegeven datatype. \autocite{IBMMainframer2021}

\begin{itemize}
    \item Voor numerieke velden (bijvoorbeeld \texttt{PIC 9(5)}) wordt het veld geïnitialiseerd met nullen.
    \item Voor alfanumerieke en alfabetische velden (bijvoorbeeld \texttt{PIC X(10)}) wordt het veld opgevuld met spaties.
\end{itemize}

Om een variabele nadien een nieuwe waarde te geven, wordt in COBOL de \texttt{MOVE}-instructie gebruikt:

\begin{lstlisting}[language=Cobol, caption={MOVE in COBOL}, label={lst:cobol_move}]
MOVE 'JOS' TO NAME.
MOVE 25 TO AGE.
MOVE -123.45 TO PRICE.
\end{lstlisting}

\subsubsection{Waar worden PIC-clausules gebruikt?}

PIC-clausules worden gebruikt in de \texttt{DATA DIVISION} van een COBOL-programma, 
meer specifiek binnen de \texttt{WORKING-STORAGE SECTION} of de \texttt{FILE SECTION}. 
Ze definiëren daar de exacte structuur, lengte en het type van gegevensvelden.

Een typisch voorbeeld in de \texttt{WORKING-STORAGE SECTION}:

\begin{lstlisting}[language=Cobol, caption={Voorbeeld van WORKING-STORAGE SECTION}, label={lst:cobol_ws}]
DATA DIVISION.
WORKING-STORAGE SECTION.
01 PERSON.
   05 NAME      PIC X(10).
   05 AGE       PIC 9(3).
   05 SALARY    PIC S9(5)V99.
\end{lstlisting}

\subsubsection{Data Hiërarchie en Level Numbers}
Waar een Python-ontwikkelaar een object of geneste \textit{dictionary} gebruikt, structureert een COBOL-ontwikkelaar data via een hiërarchie van \textit{level numbers}.

\begin{itemize}
    \item \textbf{Level 01:} Definieert een record (de wortel van de boom).
    \item \textbf{Level 05-49:} Gebruikt voor groepsitems of individuele velden binnen een record.
    \item \textbf{Level 77:} Wordt gebruikt voor losstaande variabelen die geen deel uitmaken van een hiërarchie.
    \item \textbf{Level 88:} Conditionele variabelen (Boolean-logica gekoppeld aan een waarde).
\end{itemize}

\begin{lstlisting}[language=Cobol, caption={Voorbeeld record structuur in COBOL}, label={lst:cobol_record_structuur}]
01  EMPLOYEE-DATA.
    05  EMP-ID      PIC 9(05).
    05  EMP-NAME.
        10 FIRST    PIC X(10).
        10 LAST     PIC X(10).
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Voorbeeld record structuur in Python}, label={lst:python_record_structuur}]
employee = {
    "id": 12345,
    "name": {
        "first": "Jan",
        "last": "Janssen"
    }
}
\end{lstlisting}

% TODO: iets over Object georienteerd zeggen

\subsection{Conditionals}
Het grootste verschil bij conditionele logica is de manier waarop de scope van een blok wordt afgesloten \autocite{IBM2023}.

In COBOL moet de gebruikte variabele eerst gedeclareerd worden in de \texttt{DATA DIVISION}:

\begin{lstlisting}[language=Cobol, caption={Conditional in COBOL}, label={lst:cobol_conditional}]
    IDENTIFICATION DIVISION.
    PROGRAM-ID. CONDITIONAL-VB.

    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01 WS-VARIABLES.
        05 AGE PIC 9(3) VALUE 0.

    PROCEDURE DIVISION.
    MAIN.
        IF AGE > 18
            DISPLAY 'Adult'
        ELSE
            DISPLAY 'Minor'
        END-IF.
        
        STOP RUN.
\end{lstlisting}

\begin{lstlisting}[language=python, caption={Conditional in Python}, label={lst:python_conditional}]
if age > 18:
    print("Adult")
else:
    print("Minor")
\end{lstlisting}

\subsubsection{Scope-valstrik}
In Python bepaalt de indentatie visueel waar een \texttt{if}-blok eindigt. In COBOL is dit afhankelijk van terminators, wat tot gevaarlijke situaties kan leiden.

\begin{itemize}
    \item \textbf{De Punt (\texttt{.}):} In oudere COBOL-standaarden beëindigt een punt alle actieve \texttt{IF}-statements. Als een junior per ongeluk een punt zet in een genest block, wordt de volledige logica afgebroken \autocite{IBM2023}.
    \item \textbf{Modern COBOL:} Gebruikt \texttt{END-IF} om dit risico te minimaliseren, vergelijkbaar met de sluitende \textit{brace} in C-talen, maar nog steeds explicieter dan Python.
\end{itemize}

\subsection{Loops}
Waar Python iteratoren gebruikt, gebruikt COBOL het \texttt{PERFORM}-statement voor herhaling \autocite{Foundation2026}.

In COBOL moet de teller eerst gedeclareerd worden in de \texttt{DATA DIVISION}:


\begin{lstlisting}[language=Cobol, caption={Iteratie in COBOL}, label={lst:cobol_loop}]
    IDENTIFICATION DIVISION.
    PROGRAM-ID. LOOP-VB.

    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01 I PIC 9(2) VALUE 1.

    PROCEDURE DIVISION.
    MAIN.
        PERFORM VARYING I FROM 1 BY 1 
            UNTIL I > 10
            DISPLAY I
        END-PERFORM.
        
        STOP RUN.
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Iteratie in Python}, label={lst:python_loop}]
for i in range(1, 11):
    print(i)
\end{lstlisting}

\subsection{Functies}
Waar Python expliciete functies definieert met het \texttt{def}-keyword, werkt COBOL traditioneel met paragrafen of secties die worden aangeroepen via \texttt{PERFORM}. 
In modernere COBOL-standaarden kan men ook gebruikmaken van \texttt{PROGRAM-ID} of \texttt{FUNCTION} \autocite{IBM2023}.

\begin{lstlisting}[language=Cobol, caption={Functies in COBOL}, label={lst:cobol_functie}]
    IDENTIFICATION DIVISION.
    PROGRAM-ID. FUCNTIE-VB.

    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01 WS-VARIABLES.
        05 NUM1    PIC 9(3) VALUE 5.
        05 NUM2    PIC 9(3) VALUE 3.
        05 RESULT  PIC 9(4) VALUE 0.

    PROCEDURE DIVISION.

    ADD-NUMBERS.
        COMPUTE RESULT = NUM1 + NUM2.
        STOP RUN.

    MAIN.
        PERFORM ADD-NUMBERS
        DISPLAY RESULT
        STOP RUN.

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Functie in Python}, label={lst:python_functie}]
def add_numbers(num1, num2):
    return num1 + num2

result = add_numbers(5, 3)
print(result)
\end{lstlisting}

\subsubsection{Parameter- en Return-verschillen}
Er bestaan fundamentele verschillen in hoe beide talen omgaan met parameters en returnwaarden:

\begin{itemize}
    \item \textbf{Python:} Ondersteunt expliciete parameters en een \texttt{return}-statement. Functies zijn first-class objects en kunnen worden doorgegeven als argument.
    \item \textbf{COBOL (klassiek):} Werkt vaak met globale variabelen in de \texttt{WORKING-STORAGE SECTION}. De “returnwaarde” wordt meestal opgeslagen in een gedeelde variabele.
    \item \textbf{Modern COBOL:} Ondersteunt formele parameter passing via \texttt{USING} en kan waarden teruggeven via \texttt{RETURNING}, maar blijft explicieter en verboser dan Python.
\end{itemize}


\subsection{Error Handling}
In Python is een \texttt{try-except} block de standaard. In COBOL bestaat dit concept niet native. Fouten worden afgehandeld via \textbf{Return Codes} of \textbf{File Status Codes}. 

Wanneer een bestand wordt geopend, moet de programmeur handmatig de status controleren:
\begin{itemize}
    \item \texttt{00}: Succes.
    \item \texttt{10}: End of file.
    \item \texttt{35}: Bestand niet gevonden.
\end{itemize}
Dit vereist een veel actievere en defensievere programmeerstijl dan junioren gewend zijn in Python, waar een \texttt{FileNotFoundError} automatisch de executie stopt met een duidelijke melding.

% TODO: OOP?

\section{Gamification}

TODO: fix intro en definitie
\textcite{Deterding2011} definiëren gamification als het gebruik van game-\allowbreak ontwerpelementen in niet-\allowbreak game contexten. 
\textcite{Deterding2011} leggen hun definitie uit en stellen dat gamification meer met "gamen" \textit{(ludus)} dan met "playing" \textit{(paidia)} te maken heeft, er zijn namelijk regels die moeten worden gevolgd.
Gamification  maakt  gebruik  van  elementen  uit  game-ontwerp,  maar  kan  niet  als  volwaardige  games  worden  beschouwd.

\subsection{Game-elementen}

Om gamification effectief toe te passen, worden specifieke bouwstenen uit games geïsoleerd en geïmplementeerd. 
Deze elementen fungeren als de brug tussen de systeemregels en de psychologische behoeften van de gebruiker. 
Volgens \textcite{KevinWerbach2020} kunnen deze elementen worden onderverdeeld in een hiërarchie van dynamieken, mechanieken en componenten. 
De componenten zijn de meest zichtbare uitingen hiervan, vaak samengevat onder de noemer PBL.

\subsubsection{Veelvoorkomende Game-elementen: PBL}

De meest bekende en toegepaste elementen binnen gamification staan bekend als de PBL-triade: \textit{Points}, \textit{Badges} en \textit{Leaderboards} \autocite{KevinWerbach2020}.

%TODO meer uitleg geven bij elk puntje, adhv for the win boek
\begin{itemize}
\item \textbf{Points (Punten):}
\item \textbf{Badges (Badges/Trofeeën):} 
\item \textbf{Leaderboards (Ranglijsten):}
\end{itemize}

\subsubsection{Naast PBL} %TODO
Hoewel PBL-elementen eenvoudig te implementeren zijn, is voor een duurzame gedragsverandering vaak een diepere integratie van game-ontwerp nodig. Elementen die verder gaan dan louter beloningen zijn:

\begin{itemize}
\item \textbf{Narratief (Verhaal):} Het plaatsen van taken in een contextuele verhaallijn verhoogt de betekenisgeving en de emotionele betrokkenheid van de gebruiker \autocite{Kapp2012}.
\item \textbf{Feedback-loops:} Constante en directe feedback zorgt ervoor dat gebruikers hun acties onmiddellijk kunnen aanpassen, wat essentieel is voor het leerproces en de flow-ervaring \autocite{Csikszentmihalyi1990}.
\item \textbf{Progressiebalken:} Deze visuele hulpmiddelen maken de nabijheid van een doel tastbaar, wat inspeelt op de menselijke neiging om onvoltooide taken af te willen ronden \autocite{Zichermann2011}.
\item \textbf{Avatars:} Een digitale representatie van de gebruiker bevordert de zelfexpressie en creëert een gevoel van aanwezigheid binnen het systeem \autocite{Werbach2012}.
\end{itemize}
\subsection{Frameworks}

\subsubsection{MDA-framework}
Het MDA-framework, een acroniem voor \textit{Mechanics}, \textit{Dynamics}, en \textit{Aesthetics}, is een formele methode die tracht de kloof tussen game-ontwerp, game-kritiek en technisch onderzoek te overbruggen \autocite{Hunicke2004}. 
In tegenstelling tot traditionele media wordt de inhoud van een game gedefinieerd door het gedrag van het systeem in interactie met de speler \autocite{Hunicke2004}.
\textcite{Hunicke2004} stellen dat games begrepen moeten worden als systemen die gedrag opbouwen via interactie, waarbij het raamwerk drie causale niveaus onderscheidt:

\begin{itemize}
    \item \textbf{Mechanics} beschrijft de specifieke componenten van de game op het niveau van data-representatie en algoritmen \autocite{Hunicke2004}. 
    Dit omvat de acties, regels en controlemechanismen die de ontwerper aan de speler biedt \autocite{Hunicke2004}.
    \item \textbf{Dynamics} beschrijft het \textit{run-time} gedrag van de mechanieken die inwerken op de input van de speler en elkaars output over een tijdsverloop \autocite{Hunicke2004}.
    \item \textbf{Aesthetics} verwijst naar de gewenste emotionele reacties die bij de speler worden opgeroepen tijdens de interactie met het gamesysteem \autocite{Hunicke2004}.
\end{itemize}

Een fundamenteel aspect van dit raamwerk is het verschil in perspectief tussen de ontwerper en de speler \autocite{Hunicke2004}. 
Waar de ontwerper begint bij de \textit{mechanics} om uiteindelijk een bepaalde \textit{aesthetic} te bereiken, ervaart de speler de game als eerste via de \textit{aesthetics}, die voortvloeien uit de \textit{dynamics} en de onderliggende \textit{mechanics} \autocite{Hunicke2004}. 
\textcite{Hunicke2004} beargumenteren dat deze benadering helpt om "ervaringsgericht" in plaats van enkel "functiegericht" te ontwerpen.

\subsubsection{Octalysis-framework}
%TODO: iets zeggen over de PBL Fallacy
Er is ook een populair framework dat specifiek kijkt naar de psychologische drijfveren achter deze gamedesign-\allowbreak elementen: het \textit{Octalysis-\allowbreak framework}, ontwikkeld door \textcite{Chou2015}. 
Waar de definitie van \textcite{Deterding2011} zich sterk richt op de classificatie van elementen, vertrekt Chou vanuit het principe van \textit{Human-Focused Design}.
Dit houdt in dat het ontwerp niet primair draait om de functionele elementen (zoals badges of leaderboards), maar om de manier waarop deze elementen inspelen op de menselijke motivatie en emoties.
Het framework is opgebouwd rond acht fundamentele motivaties, de \textit{Core Drives}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{octalysis.jpg}
  \caption{Octalysis Framework \autocite{Chou2015}}
  \label{fig:octalysis}
\end{figure}


\subsection{Effectiviteit} %TODO

\subsubsection{Gamification bij junior developers} %TODO

Een meta-analyse studie van \textcite{Zhan2022} toont ook aan dat gamification een positieve impact heeft op het onderwijs in programmeren. 
Gamification had met name het grootste effect op de motivatie en academische prestaties van studenten, gevolgd door het denkvermogen.

\subsubsection{Succesfactoren en Valkuilen} %TODO


\subsection{hoe Effectiviteit meten} %TODO