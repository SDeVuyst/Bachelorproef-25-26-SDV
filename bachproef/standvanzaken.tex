\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

In dit hoofdstuk wordt de theoretische basis gelegd voor het verdere onderzoek. 
Er wordt gestart met een verkenning van de mainframe-sector en de de rol die Cobol daarin speelt

% ----------------------------------------------------------------------------------------------------- %
\section{De Mainframe Wereld: Kritieke Infrastructuur in Transitie}
\label{sec:mainframe-wereld}

\subsection{Het platform achter de code}

Om de context waarin een junior Cobol-developer terechtkomt te kaderen, is het essentieel om eerst het mainframe-platform te definiëren. 
Volgens de definitie van \textcite{IBM2010} is een mainframe een server die door bedrijven wordt gebruikt om commerciële databases, transactieservers en applicaties te hosten die een hogere mate van beveiliging en beschikbaarheid vereisen dan doorgaans beschikbaar is op kleinere machines.

Deze servers draaien op gespecialiseerde besturingssystemen zoals z/OS (IBM) of ClearPath MCP (Unisys).
De hardware en software zijn inherent ontworpen met de strenge eisen van een enterprise-omgeving in gedachten, vaak samengevat onder de noemer \textbf{RAS} \autocite{Ebbers2011}:

\begin{itemize}
  \item \textbf{Betrouwbaarheid (Reliability):} Zelfherstellende hardware en uitgebreid geteste software minimaliseren de kans op systeemfouten.
  \item \textbf{Beschikbaarheid (Availability):} Het systeem kan herstellen van defecten zonder downtime, wat cruciaal is voor 24/7 dienstverlening.
  \item \textbf{Onderhoudsvriendelijkheid (Serviceability):} Snelle foutdetectie en diagnose maken efficiënt beheer mogelijk.
\end{itemize}

Naast de RAS-kenmerken is \textbf{blijvende compatibiliteit} een cruciale pijler: het unieke vermogen om applicaties die decennia geleden zijn geschreven (vaak in Cobol), zonder grote wijzigingen te kunnen blijven draaien op de nieuwste generaties hardware.

Hoewel critici in de jaren '90, zoals Stewart Alsop, voorspelden dat de laatste mainframe in 1996 zou worden uitgeschakeld \autocite{Alsop1991}, vormt het platform vandaag de dag nog steeds de onzichtbare ruggengraat van de wereldeconomie.

\subsection{De blijvende relevantie van Cobol}

De gebruikers van mainframes bevinden zich in sectoren waar de verwerking van enorme transactievolumes en extreme betrouwbaarheid cruciaal zijn. 
De programmeertaal Cobol (\textit{Common Business Oriented Language}), waarvan de eerste versie in 1960 werd gelanceerd, is hierbij de standaard. 
Ondanks de leeftijd van de taal, wordt de hoeveelheid Cobol-code in actieve productieomgevingen momenteel geschat op 250 miljard regels \autocite{IBM2025}.

Deze enorme codebase vormt de basis voor kritieke sectoren zoals:
\begin{itemize}
      \item \textbf{Financiële instellingen:} Mainframes verwerken naar schatting 85\% van het wereldwijde betalingsverkeer. 45 van de top 50 banken, waaronder instellingen zoals ING en de ECB, maken gebruik van deze systemen \autocite{IBM2022a, Unisys}.
      \item \textbf{Overheid en Zorg:} Cruciale diensten zoals pensioenuitbetalingen, belastinginning en de beveiliging van patiëntgegevens rusten op Cobol-applicaties die door de jaren heen zijn geoptimaliseerd \autocite{IBM2022}.
      \item \textbf{Retail en Logistiek:} Grote retailers en logistieke bedrijven vertrouwen op de ongeëvenaarde verwerkingskracht voor voorraadbeheer en transactieverwerking op globale schaal.
\end{itemize}

De marktwaarde onderstreept deze relevantie: in 2022 werd de mainframemarkt geschat op 2,9 miljard dollar, met een verwachte groei naar 5,6 miljard dollar in 2032 \autocite{Allied2022}. 
Dat Cobol-systemen de ruggengraat van de wereldeconomie blijven vormen, wordt bevestigd door het feit dat ze bijna 70\% van de wereldwijde IT-workloads voor productie verwerken \autocite{Granger2021}.


\subsection{De generatieshift en de kenniskloof}

Hoewel het mainframe een bewezen technologie is die al decennia lang ondernemingen ondersteunt, vindt er momenteel een fundamentele verschuiving plaats in wie dit platform beheert. 
Waar de systemen voorheen het domein waren van de 'Baby Boomer'-generatie, is de langverwachte generatiewissel nu een feit. 
Uit recent onderzoek van \autocite{BMC2025} blijkt dat inmiddels 66\% van de mainframe-professionals tot de Millennials of Generatie Z behoort, terwijl het aandeel Boomers en Gen X is gekrompen tot minder dan de helft.

Deze verschuiving brengt echter een kritieke uitdaging met zich mee: een groeiend tekort aan expertise. Terwijl ervaren COBOL-specialisten met pensioen gaan, worden de huidige softwareontwikkelaars voornamelijk opgeleid in moderne programmeertalen \autocite{IBM2025}. 
Dit creëert een kloof op de arbeidsmarkt, waarbij er steeds minder programmeurs beschikbaar zijn die de complexe COBOL-applicaties kunnen beheren en updaten \autocite{IBM2025}.
Voor een junior developer betekent dit niet alleen een taalkundige barrière, maar ook een verschuiving in de manier waarop zij met legacy-systemen moeten omgaan.

De noodzaak om deze nieuwe generatie aan te trekken en op te leiden is zichtbaar in de bedrijfsstrategieën. 
80\% van de bedrijven heeft in 2025 hun mainframe-strategie aangepast met het oog op modernisering \autocite{Kyndryl2025}. 
Van deze projecten is slechts 16\% gericht op het verlaten van het platform; de meerderheid kiest voor integratie met de cloud (34\%) of modernisering op het mainframe zelf (43\%) \autocite{Kyndryl2025}.
Deze cijfers onderstrepen dat COBOL-expertise cruciaal blijft, maar dat de methode waarop deze kennis wordt overgedragen aan de nieuwe generatie developers moet evolueren.

% ----------------------------------------------------------------------------------------------------- %
\section{COBOL versus Python}
\label{sec:cobol-versus-python}

De overstap van Python naar COBOL vereist een deconstructie van moderne abstractielagen. Waar Python de hardware beheert voor de programmeur, dwingt COBOL de programmeur om de hardware (geheugen en bestanden) expliciet aan te sturen.

\subsection{De Vier Divisions: De Anatomie van een Programma}
In tegenstelling tot Python-scripts, die vaak top-down worden uitgevoerd, is een COBOL-programma een rigide raamwerk. Elke \textit{Division} heeft een specifiek doel dat in moderne talen vaak geabstraheerd is in configuratiebestanden of runtime-omgevingen \autocite{IBM2023_Ref}.

\begin{itemize}
    \item \textbf{IDENTIFICATION DIVISION:} Bevat de metadata. Het is de enige verplichte divisie waarin de \texttt{PROGRAM-ID} wordt gedefinieerd. Dit fungeert als de unieke naam waarmee het programma door het besturingssysteem (zoals z/OS) wordt aangeroepen.
    \item \textbf{ENVIRONMENT DIVISION:} Hier vindt de koppeling plaats tussen de logische programmastructuur en de fysieke hardware. In de \texttt{INPUT-OUTPUT SECTION} worden fysieke datasets (bestanden) gekoppeld aan interne namen. In Python gebeurt dit dynamisch via variabelen, maar in COBOL is dit een statische configuratie.
    \item \textbf{DATA DIVISION:} De meest omvangrijke sectie voor databeheer. Hieronder valt de \texttt{WORKING-STORAGE SECTION}, waar elke variabele die het programma gebruikt, vooraf moet worden gealloceerd. COBOL kent geen \textit{garbage collection} of dynamische geheugenallocatie zoals Python \autocite{Ebbers2011}.
    \item \textbf{PROCEDURE DIVISION:} De plaats waar de executabele algoritmen staan. Deze is onderverdeeld in \textit{Paragraphs} en \textit{Sections}, die dienen als de primaire eenheden voor logische groepering, bij gebrek aan native functies of klasses in de basisstructuur.
\end{itemize}

\subsection{Datatypen en de PICTURE-clausule}
In Python is een variabele een referentie naar een object in het geheugen. In COBOL is een variabele een directe definitie van een reeks bytes. De \texttt{PICTURE}-clausule (\texttt{PIC}) bepaalt hoe deze bytes geïnterpreteerd moeten worden \autocite{IBM2023_Ref}.

\subsubsection{De PIC-symbolen}
De meest voorkomende symbolen in een \texttt{PIC}-clausule zijn:
\begin{itemize}
    \item \textbf{\texttt{9}} (Numeriek): Representeert exact één cijfer (0-9).
    \item \textbf{\texttt{X}} (Alfanumeriek): Representeert elk karakter (letter, cijfer, symbool).
    \item \textbf{\texttt{A}} (Alfabetisch): Enkel letters en spaties.
    \item \textbf{\texttt{V}} (Impliciet decimaalteken): Geeft de positie van de komma aan zonder een fysieke byte te gebruiken. Dit is essentieel voor financiële berekeningen op mainframes.
    \item \textbf{\texttt{S}} (Sign): Geeft aan dat een numeriek veld een positief of negatief teken kan bevatten.
\end{itemize}

\begin{table}[h!]
\centering
\caption{Gedetailleerde vergelijking van datadefinities}
\label{tab:pic-vergelijking}
\begin{tabular}{|l|l|p{4cm}|p{5cm}|}
\hline
\textbf{Type} & \textbf{COBOL Definitie} & \textbf{Python Equivalent} \\ \hline
Integer & \texttt{PIC 9(05)} & \texttt{age = 12345} \\ \hline
String & \texttt{PIC X(10)} & \texttt{name = "Jan"} \\ \hline
Decimal & \texttt{PIC S9(5)V99} & \texttt{price = -123.45} \\ \hline
\end{tabular}
\end{table}

% TODO: MOVE TO

\subsection{Data Hiërarchie en Level Numbers}
Waar een Python-ontwikkelaar een object of geneste \textit{dictionary} gebruikt, structureert een COBOL-ontwikkelaar data via een hiërarchie van \textit{level numbers}.

\begin{itemize}
    \item \textbf{Level 01:} Definieert een record (de wortel van de boom).
    \item \textbf{Level 05-49:} Gebruikt voor groepsitems of individuele velden binnen een record.
    \item \textbf{Level 77:} Wordt gebruikt voor losstaande variabelen die geen deel uitmaken van een hiërarchie.
    \item \textbf{Level 88:} Conditionele variabelen (Boolean-logica gekoppeld aan een waarde).
\end{itemize}

\begin{table}[h!]
\centering
\caption{Vergelijking van datastructuren}
\label{tab:data-hiërarchie}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{COBOL Record Structuur} & \textbf{Python Equivalent} \\ \hline
\begin{minipage}[t]{7cm}
\begin{verbatim}
01  EMPLOYEE-DATA.
    05  EMP-ID      PIC 9(05).
    05  EMP-NAME.
        10 FIRST    PIC X(10).
        10 LAST     PIC X(10).
\end{verbatim}
\end{minipage} & 
\begin{minipage}[t]{7cm}
\begin{verbatim}
employee = {
    "id": 12345,
    "name": {
        "first": "Jan",
        "last": "Janssen"
    }
}
\end{verbatim}
\end{minipage} \\ \hline
\end{tabular}
\end{table}

% TODO: komt in welke section?
\subsection{Conditionals}
Het grootste verschil bij conditionele logica is de manier waarop de scope van een blok wordt afgesloten \autocite{IBM2023_Ref}.

\begin{table}[h!]
\centering
\caption{Vergelijking van Conditionals}
\label{tab:conditional-vergelijking}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{COBOL (Expliciete terminators)} & \textbf{Python (Indentatie)} \\ \hline
\begin{minipage}[t]{7cm}
\begin{verbatim}
IF AGE > 18
    DISPLAY 'Adult'
ELSE
    DISPLAY 'Minor'
END-IF.
\end{verbatim}
\end{minipage} & 
\begin{minipage}[t]{7cm}
\begin{verbatim}
if age > 18:
    print("Adult")
else:
    print("Minor")
\end{verbatim}
\end{minipage} \\ \hline
\end{tabular}
\end{table}

\subsubsection{Scope-valstrik}
In Python bepaalt de indentatie visueel waar een \texttt{if}-blok eindigt. In COBOL is dit afhankelijk van terminators, wat tot gevaarlijke situaties kan leiden.

\begin{itemize}
    \item \textbf{De Punt (\texttt{.}):} In oudere COBOL-standaarden beëindigt een punt alle actieve \texttt{IF}-statements. Als een junior per ongeluk een punt zet in een genest block, wordt de volledige logica afgebroken \autocite{IBM2023_Ref}.
    \item \textbf{Modern COBOL:} Gebruikt \texttt{END-IF} om dit risico te minimaliseren, vergelijkbaar met de sluitende \textit{brace} in C-talen, maar nog steeds explicieter dan Python.
\end{itemize}

\subsection{Loops}
Waar Python iteratoren gebruikt, gebruikt COBOL het \texttt{PERFORM}-statement voor herhaling \autocite{PythonDoc}.

\begin{table}[h!]
\centering
\caption{Vergelijking van Iteratie}
\label{tab:loop-vergelijking}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{COBOL (Perform)} & \textbf{Python (For-in)} \\ \hline
\begin{minipage}[t]{7cm}
\begin{verbatim}
PERFORM VARYING I FROM 1 BY 1 
    UNTIL I > 10
    DISPLAY I
END-PERFORM.
\end{verbatim}
\end{minipage} & 
\begin{minipage}[t]{7cm}
\begin{verbatim}
for i in range(1, 11):
    print(i)
\end{verbatim}
\end{minipage} \\ \hline
\end{tabular}
\end{table}

\subsection{Functies}

% TODO


\subsection{Error Handling: De afwezigheid van Exceptions}
In Python is een \texttt{try-except} block de standaard. In COBOL bestaat dit concept niet native. Fouten worden afgehandeld via \textbf{Return Codes} of \textbf{File Status Codes}. 

Wanneer een bestand wordt geopend, moet de programmeur handmatig de status controleren:
\begin{itemize}
    \item \texttt{00}: Succes.
    \item \texttt{10}: End of file.
    \item \texttt{35}: Bestand niet gevonden.
\end{itemize}
Dit vereist een veel actievere en defensievere programmeerstijl dan junioren gewend zijn in Python, waar een \texttt{FileNotFoundError} automatisch de executie stopt met een duidelijke melding.

\subsection{OOP: Procedurele basis versus Object-Native}
Python is gebouwd rond klassen. COBOL is gebouwd rond \textit{procedures}. Hoewel OO-COBOL bestaat, is het belangrijkste verschil voor de junior de \textbf{data-persistentie}. In Python leven objecten in de \textit{heap}. In COBOL is de data vaak globaal binnen het programma (\texttt{WORKING-STORAGE}), wat betekent dat onbedoelde neveneffecten (side-effects) vaker voorkomen bij het aanroepen van verschillende \textit{Paragraphs}.


\section{Gamification}

\textcite{Deterding2011} definiëren gamification als het gebruik van game-\allowbreak ontwerpelementen in niet-\allowbreak game contexten. 
\textcite{Deterding2011} leggen hun definitie uit en stellen dat gamification meer met "gamen" \textit{(ludus)} dan met "playing" \textit{(paidia)} te maken heeft, er zijn namelijk regels die moeten worden gevolgd.
Gamification  maakt  gebruik  van  elementen  uit  game-ontwerp,  maar  kan  niet  als  volwaardige  games  worden  beschouwd.

Om te verduidelijken welke elementen hieronder vallen, onderscheiden de auteurs vijf niveaus van gamedesign-elementen, geordend van concreet naar abstract:
\begin{itemize} 
    \item \textbf{Game interface design patterns:} Dit zijn de meest directe visuele oplossingen en interactiecomponenten, zoals badges, leaderboards en levels. 
    \item \textbf{Game design patterns en mechanics:} Deze omvatten de terugkerende onderdelen van de gameplay die de interactie structureren, zoals tijdslimieten, beperkte middelen of het werken met beurten. 
    \item \textbf{Game design principes en heuristieken:} Dit zijn evaluatieve richtlijnen om een ontwerp aan te pakken of te analyseren, zoals het bieden van duidelijke doelen of een variëteit aan spelstijlen. 
    \item \textbf{Game modellen:} Dit betreft conceptuele modellen van game-componenten of de game-ervaring, zoals het MDA-model (Mechanics, Dynamics, Aesthetics). 
    \item \textbf{Game design methoden:} Dit zijn de specifieke praktijken en ontwerpprocessen uit de gamedesignwereld, waaronder playtesting en playcentric design.
\end{itemize}

Er is ook een populair framework dat specifiek kijkt naar de psychologische drijfveren achter deze gamedesign-\allowbreak elementen: het \textit{Octalysis-\allowbreak framework}, ontwikkeld door \textcite{Chou2015}. 
Waar de definitie van \textcite{Deterding2011} zich sterk richt op de classificatie van elementen, vertrekt Chou vanuit het principe van \textit{Human-Focused Design}.
Dit houdt in dat het ontwerp niet primair draait om de functionele elementen (zoals badges of leaderboards), maar om de manier waarop deze elementen inspelen op de menselijke motivatie en emoties.
Het framework is opgebouwd rond acht fundamentele motivaties, de \textit{Core Drives}. 
Deze \textit{Core Drives} bevatten 8 verschillende aspecten van de menselijke psychologie zoals \textit{Development \& Accomplishment}, \textit{Ownership}, \textit{Social Influence} etc. \autocite{Chou2015}

Een meta-analyse studie van \textcite{Zhan2022} toont ook aan dat gamification een positieve impact heeft op het onderwijs in programmeren. 
Gamification had met name het grootste effect op de motivatie en academische prestaties van studenten, gevolgd door het denkvermogen.
