\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

In dit hoofdstuk wordt de theoretische basis gelegd voor het verdere onderzoek. 
%TODO

% ----------------------------------------------------------------------------------------------------- %
\section{De Mainframe Wereld: Kritieke Infrastructuur in Transitie}
\label{sec:mainframe-wereld}

\subsection{Het platform achter de code}

Om de context waarin een junior COBOL-developer terechtkomt te kaderen, is het essentieel om eerst het mainframe-platform te definiëren. 
Volgens de definitie van \textcite{IBM2010} is een mainframe een server die door bedrijven wordt gebruikt om commerciële databases, transactieservers en applicaties te hosten die een hogere mate van beveiliging en beschikbaarheid vereisen dan doorgaans beschikbaar is op kleinere machines.

Deze servers draaien op gespecialiseerde besturingssystemen zoals z/OS (IBM) of ClearPath MCP (Unisys).
De hardware en software zijn inherent ontworpen met de strenge eisen van een enterprise-omgeving in gedachten, vaak samengevat onder de noemer \textbf{RAS} \autocite{Ebbers2011}:

\begin{itemize}
  \item \textbf{Betrouwbaarheid (Reliability):} Zelfherstellende hardware en uitgebreid geteste software minimaliseren de kans op systeemfouten.
  \item \textbf{Beschikbaarheid (Availability):} Het systeem kan herstellen van defecten zonder downtime, wat cruciaal is voor 24/7 dienstverlening.
  \item \textbf{Onderhoudsvriendelijkheid (Serviceability):} Snelle foutdetectie en diagnose maken efficiënt beheer mogelijk.
\end{itemize}

Naast de RAS-kenmerken is \textbf{blijvende compatibiliteit} een cruciale pijler: het unieke vermogen om applicaties die decennia geleden zijn geschreven (vaak in COBOL), zonder grote wijzigingen te kunnen blijven draaien op de nieuwste generaties hardware.

Hoewel critici in de jaren '90, zoals Stewart Alsop, voorspelden dat de laatste mainframe in 1996 zou worden uitgeschakeld \autocite{Alsop1991}, vormt het platform vandaag de dag nog steeds de onzichtbare ruggengraat van de wereldeconomie.

\subsection{De blijvende relevantie van COBOL}

De gebruikers van mainframes bevinden zich in sectoren waar de verwerking van enorme transactievolumes en extreme betrouwbaarheid cruciaal zijn. 
De programmeertaal COBOL (\textit{Common Business Oriented Language}), waarvan de eerste versie in 1960 werd gelanceerd, is hierbij de standaard. 
Ondanks de leeftijd van de taal, wordt de hoeveelheid COBOL-code in actieve productieomgevingen momenteel geschat op 250 miljard regels \autocite{IBM2025}.

Deze enorme codebase vormt de basis voor kritieke sectoren zoals:
\begin{itemize}
      \item \textbf{Financiële instellingen:} Mainframes verwerken naar schatting 85\% van het wereldwijde betalingsverkeer. 45 van de top 50 banken, waaronder instellingen zoals ING en de ECB, maken gebruik van deze systemen \autocite{IBM2022a}.
      \item \textbf{Overheid en Zorg:} Cruciale diensten zoals pensioenuitbetalingen, belastinginning en de beveiliging van patiëntgegevens rusten op COBOL-applicaties die door de jaren heen zijn geoptimaliseerd \autocite{IBM2022}.
      \item \textbf{Retail en Logistiek:} Grote retailers en logistieke bedrijven vertrouwen op de ongeëvenaarde verwerkingskracht voor voorraadbeheer en transactieverwerking op globale schaal.
\end{itemize}

De marktwaarde onderstreept deze relevantie: in 2022 werd de mainframemarkt geschat op 2,9 miljard dollar, met een verwachte groei naar 5,6 miljard dollar in 2032 \autocite{Allied2022}. 
Dat COBOL-systemen de ruggengraat van de wereldeconomie blijven vormen, wordt bevestigd door het feit dat ze bijna 70\% van de wereldwijde IT-workloads voor productie verwerken \autocite{Granger2021}.


\subsection{De generatieshift en de kenniskloof}

Hoewel het mainframe een bewezen technologie is die al decennia lang ondernemingen ondersteunt, vindt er momenteel een fundamentele verschuiving plaats in wie dit platform beheert. 
Waar de systemen voorheen het domein waren van de 'Baby Boomer'-generatie, is de langverwachte generatiewissel nu een feit. 
Uit recent onderzoek van \autocite{BMC2025} blijkt dat inmiddels 66\% van de mainframe-professionals tot de Millennials of Generatie Z behoort, terwijl het aandeel Boomers en Gen X is gekrompen tot minder dan de helft.

Deze verschuiving brengt echter een kritieke uitdaging met zich mee: een groeiend tekort aan expertise. Terwijl ervaren COBOL-specialisten met pensioen gaan, worden de huidige softwareontwikkelaars voornamelijk opgeleid in moderne programmeertalen \autocite{IBM2025}. 
Dit creëert een kloof op de arbeidsmarkt, waarbij er steeds minder programmeurs beschikbaar zijn die de complexe COBOL-applicaties kunnen beheren en updaten \autocite{IBM2025}.
Voor een junior developer betekent dit niet alleen een taalkundige barrière, maar ook een verschuiving in de manier waarop zij met legacy-systemen moeten omgaan.

% TODO: dit past misschien beter bij probleemstelling
De noodzaak om deze nieuwe generatie aan te trekken en op te leiden is zichtbaar in de bedrijfsstrategieën. 
80\% van de bedrijven heeft in 2025 hun mainframe-strategie aangepast met het oog op modernisering \autocite{Kyndryl2025}. 
Van deze projecten is slechts 16\% gericht op het verlaten van het platform; de meerderheid kiest voor integratie met de cloud (34\%) of modernisering op het mainframe zelf (43\%) \autocite{Kyndryl2025}.
Deze cijfers onderstrepen dat COBOL-expertise cruciaal blijft, maar dat de methode waarop deze kennis wordt overgedragen aan de nieuwe generatie developers moet evolueren.

% ----------------------------------------------------------------------------------------------------- %
\section{COBOL versus Python}
\label{sec:COBOL-versus-python}

Om de barrières bloot te leggen waarmee junior developers het moeilijk mee hebben is het belangrijk om te weten hoe de opbouw van COBOL ineenzit aangezien de syntax en logica afwijkt van de moderne talen die vandaag de dag in het onderwijs aangeleerd worden.
In dit hoofdstuk trekken we een vergelijking met Python. 
Python dient hierbij als het ideale referentiepunt, aangezien het momenteel de meest gehanteerde taal is voor beginnende programmeurs vanwege de leesbaarheid en intuïtieve structuur.

\subsection{Programmastructuur}
In tegenstelling tot Python-scripts, die vaak top-down worden uitgevoerd, volgt een COBOL-programma een strak gedefinieerde structuur. \autocite{TutorialsPoint}

\begin{figure}[H]
\centering
\begin{minipage}{0.45\textwidth}
  \begin{itemize}
    \item \textbf{Divisions:} De logische onderverdeling van de programmalogica. Een sectie is een verzameling van paragrafen.
    \item \textbf{Paragraphs:} De onderverdeling van een sectie of divisie. Het is een door de gebruiker gedefinieerde of vooraf gedefinieerde naam gevolgd door een punt, en bestaat uit nul of meer zinnen.
    \item \textbf{Sentences:} De combinatie van een of meer uitspraken. Zinnen komen alleen voor in de \textit{Procedure Division}. Een zin moet eindigen met een punt.
    \item \textbf{Statements:} zinvolle COBOL-instructies die bepaalde bewerkingen uitvoeren.
  \end{itemize}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
  \centering
  \includegraphics[width=\linewidth]{program_structure_COBOL.jpg}
  \caption{Programmastructuur COBOL \autocite{TutorialsPoint}}
  \label{fig:program_structure_COBOL_jpg}
\end{minipage}

\end{figure}

Een COBOL programma bestaat uit 4 \textit{Divisions}: \autocite{IBMMainframer2021}

\begin{itemize}
    \item \textbf{IDENTIFICATION DIVISION:} Bevat de metadata. Het is de enige verplichte divisie waarin de \texttt{PROGRAM-ID} wordt gedefinieerd.
    Dit fungeert als de unieke naam waarmee het programma door het besturingssysteem (zoals z/OS) wordt aangeroepen.
    \item \textbf{ENVIRONMENT DIVISION:} Hier vindt de koppeling plaats tussen de logische programmastructuur en de fysieke hardware. In de \texttt{INPUT-OUTPUT SECTION} worden fysieke datasets (bestanden) gekoppeld aan interne namen. In Python gebeurt dit dynamisch via variabelen, maar in COBOL is dit een statische configuratie.
    \item \textbf{DATA DIVISION:} De meest omvangrijke sectie voor databeheer. Hieronder valt de \texttt{WORKING-STORAGE SECTION}, waar elke variabele die het programma gebruikt, vooraf moet worden gealloceerd. COBOL kent geen \textit{garbage collection} of dynamische geheugenallocatie zoals Python \autocite{Ebbers2011}.
    \item \textbf{PROCEDURE DIVISION:} De plaats waar de executabele algoritmen staan. Deze is onderverdeeld in \textit{Paragraphs} en \textit{Sections}, die dienen als de primaire eenheden voor logische groepering, bij gebrek aan native functies of klasses in de basisstructuur.
\end{itemize}

\subsection{Datatypen en de PICTURE-clausule}
In Python is een variabele een referentie naar een object in het geheugen. 
In COBOL is een variabele een directe definitie van een reeks bytes. 
De \texttt{PICTURE}-clausule (\texttt{PIC}) bepaalt hoe deze bytes geïnterpreteerd moeten worden \autocite{IBM2023}.

\subsubsection{De PIC-symbolen}

De meest voorkomende symbolen in een \texttt{PIC}-clausule zijn:
\begin{itemize}
    \item \textbf{\texttt{9}} (Numeriek): Representeert exact één cijfer (0-9).
    \item \textbf{\texttt{X}} (Alfanumeriek): Representeert elk karakter (letter, cijfer, symbool).
    \item \textbf{\texttt{A}} (Alfabetisch): Enkel letters en spaties.
    \item \textbf{\texttt{V}} (Impliciet decimaalteken): Geeft de positie van de komma aan zonder een fysieke byte te gebruiken. Dit is essentieel voor financiële berekeningen op mainframes.
    \item \textbf{\texttt{S}} (Sign): Geeft aan dat een numeriek veld een positief of negatief teken kan bevatten.
\end{itemize}

\begin{table}[h!]
    \centering
    \caption{Vergelijking van datadefinities}
    \label{tab:pic-vergelijking}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Type} & \textbf{COBOL Definitie} & \textbf{Python Equivalent} \\ \hline
        Integer & \texttt{05 AGE PIC 9(05) VALUE 12345} & \texttt{age = 12345} \\ \hline
        String & \texttt{05 NAME PIC X(10) VALUE 'JOS'} & \texttt{name = "Jos"} \\ \hline
        Decimal & \texttt{05 PRICE PIC S9(5)V99 VALUE -123.45} & \texttt{price = -123.45} \\ \hline
    \end{tabular}
\end{table}

De \texttt{PIC}- of \texttt{PICTURE}-clausule kan ook worden geschreven zonder de \texttt{VALUE}-clausule. 
In dat geval wordt de variabele automatisch geïnitialiseerd met de standaardwaarde van het opgegeven datatype. \autocite{IBMMainframer2021}

\begin{itemize}
    \item Voor numerieke velden (bijvoorbeeld \texttt{PIC 9(5)}) wordt het veld geïnitialiseerd met nullen.
    \item Voor alfanumerieke en alfabetische velden (bijvoorbeeld \texttt{PIC X(10)}) wordt het veld opgevuld met spaties.
\end{itemize}

Om een variabele nadien een nieuwe waarde te geven, wordt in COBOL de \texttt{MOVE}-instructie gebruikt:

\begin{lstlisting}[language=Cobol, caption={MOVE in COBOL}, label={lst:cobol_move}]
MOVE 'JOS' TO NAME.
MOVE 25 TO AGE.
MOVE -123.45 TO PRICE.
\end{lstlisting}

\subsubsection{Waar worden PIC-clausules gebruikt?}

PIC-clausules worden gebruikt in de \texttt{DATA DIVISION} van een COBOL-programma, 
meer specifiek binnen de \texttt{WORKING-STORAGE SECTION} of de \texttt{FILE SECTION}. 
Ze definiëren daar de exacte structuur, lengte en het type van gegevensvelden.

Een typisch voorbeeld in de \texttt{WORKING-STORAGE SECTION}:

\begin{lstlisting}[language=Cobol, caption={Voorbeeld van WORKING-STORAGE SECTION}, label={lst:cobol_ws}]
DATA DIVISION.
WORKING-STORAGE SECTION.
01 PERSON.
   05 NAME      PIC X(10).
   05 AGE       PIC 9(3).
   05 SALARY    PIC S9(5)V99.
\end{lstlisting}

\subsubsection{Data Hiërarchie en Level Numbers}
Waar een Python-ontwikkelaar een object of geneste \textit{dictionary} gebruikt, structureert een COBOL-ontwikkelaar data via een hiërarchie van \textit{level numbers}.

\begin{itemize}
    \item \textbf{Level 01:} Definieert een record (de wortel van de boom).
    \item \textbf{Level 05-49:} Gebruikt voor groepsitems of individuele velden binnen een record.
    \item \textbf{Level 77:} Wordt gebruikt voor losstaande variabelen die geen deel uitmaken van een hiërarchie.
    \item \textbf{Level 88:} Conditionele variabelen (Boolean-logica gekoppeld aan een waarde).
\end{itemize}

\begin{lstlisting}[language=Cobol, caption={Voorbeeld record structuur in COBOL}, label={lst:cobol_record_structuur}]
01  EMPLOYEE-DATA.
    05  EMP-ID      PIC 9(05).
    05  EMP-NAME.
        10 FIRST    PIC X(10).
        10 LAST     PIC X(10).
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Voorbeeld record structuur in Python}, label={lst:python_record_structuur}]
employee = {
    "id": 12345,
    "name": {
        "first": "Jan",
        "last": "Janssen"
    }
}
\end{lstlisting}

% TODO: iets over Object georienteerd zeggen

\subsection{Conditionals}
Het grootste verschil bij conditionele logica is de manier waarop de scope van een blok wordt afgesloten \autocite{IBM2023}.

In COBOL moet de gebruikte variabele eerst gedeclareerd worden in de \texttt{DATA DIVISION}:

\begin{lstlisting}[language=Cobol, caption={Conditional in COBOL}, label={lst:cobol_conditional}]
    IDENTIFICATION DIVISION.
    PROGRAM-ID. CONDITIONAL-VB.

    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01 WS-VARIABLES.
        05 AGE PIC 9(3) VALUE 0.

    PROCEDURE DIVISION.
    MAIN.
        IF AGE > 18
            DISPLAY 'Adult'
        ELSE
            DISPLAY 'Minor'
        END-IF.
        
        STOP RUN.
\end{lstlisting}

\begin{lstlisting}[language=python, caption={Conditional in Python}, label={lst:python_conditional}]
if age > 18:
    print("Adult")
else:
    print("Minor")
\end{lstlisting}

\subsubsection{Scope-valstrik}
In Python bepaalt de indentatie visueel waar een \texttt{if}-blok eindigt. In COBOL is dit afhankelijk van terminators, wat tot gevaarlijke situaties kan leiden.

\begin{itemize}
    \item \textbf{De Punt (\texttt{.}):} In oudere COBOL-standaarden beëindigt een punt alle actieve \texttt{IF}-statements. Als een junior per ongeluk een punt zet in een genest block, wordt de volledige logica afgebroken \autocite{IBM2023}.
    \item \textbf{Modern COBOL:} Gebruikt \texttt{END-IF} om dit risico te minimaliseren, vergelijkbaar met de sluitende \textit{brace} in C-talen, maar nog steeds explicieter dan Python.
\end{itemize}

\subsection{Loops}
Waar Python iteratoren gebruikt, gebruikt COBOL het \texttt{PERFORM}-statement voor herhaling \autocite{Foundation2026}.

In COBOL moet de teller eerst gedeclareerd worden in de \texttt{DATA DIVISION}:


\begin{lstlisting}[language=Cobol, caption={Iteratie in COBOL}, label={lst:cobol_loop}]
    IDENTIFICATION DIVISION.
    PROGRAM-ID. LOOP-VB.

    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01 I PIC 9(2) VALUE 1.

    PROCEDURE DIVISION.
    MAIN.
        PERFORM VARYING I FROM 1 BY 1 
            UNTIL I > 10
            DISPLAY I
        END-PERFORM.
        
        STOP RUN.
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Iteratie in Python}, label={lst:python_loop}]
for i in range(1, 11):
    print(i)
\end{lstlisting}

\subsection{Functies}
Waar Python expliciete functies definieert met het \texttt{def}-keyword, werkt COBOL traditioneel met paragrafen of secties die worden aangeroepen via \texttt{PERFORM}. 
In modernere COBOL-standaarden kan men ook gebruikmaken van \texttt{PROGRAM-ID} of \texttt{FUNCTION} \autocite{IBM2023}.

\begin{lstlisting}[language=Cobol, caption={Functies in COBOL}, label={lst:cobol_functie}]
    IDENTIFICATION DIVISION.
    PROGRAM-ID. FUCNTIE-VB.

    DATA DIVISION.
    WORKING-STORAGE SECTION.
    01 WS-VARIABLES.
        05 NUM1    PIC 9(3) VALUE 5.
        05 NUM2    PIC 9(3) VALUE 3.
        05 RESULT  PIC 9(4) VALUE 0.

    PROCEDURE DIVISION.

    ADD-NUMBERS.
        COMPUTE RESULT = NUM1 + NUM2.
        STOP RUN.

    MAIN.
        PERFORM ADD-NUMBERS
        DISPLAY RESULT
        STOP RUN.

\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Functie in Python}, label={lst:python_functie}]
def add_numbers(num1, num2):
    return num1 + num2

result = add_numbers(5, 3)
print(result)
\end{lstlisting}

\subsubsection{Parameter- en Return-verschillen}
Er bestaan fundamentele verschillen in hoe beide talen omgaan met parameters en returnwaarden:

\begin{itemize}
    \item \textbf{Python:} Ondersteunt expliciete parameters en een \texttt{return}-statement. Functies zijn first-class objects en kunnen worden doorgegeven als argument.
    \item \textbf{COBOL (klassiek):} Werkt vaak met globale variabelen in de \texttt{WORKING-STORAGE SECTION}. De “returnwaarde” wordt meestal opgeslagen in een gedeelde variabele.
    \item \textbf{Modern COBOL:} Ondersteunt formele parameter passing via \texttt{USING} en kan waarden teruggeven via \texttt{RETURNING}, maar blijft explicieter en verboser dan Python.
\end{itemize}


\subsection{Error Handling}
In Python is een \texttt{try-except} block de standaard. In COBOL bestaat dit concept niet native. Fouten worden afgehandeld via \textbf{Return Codes} of \textbf{File Status Codes}. 

Wanneer een bestand wordt geopend, moet de programmeur handmatig de status controleren:
\begin{itemize}
    \item \texttt{00}: Succes.
    \item \texttt{10}: End of file.
    \item \texttt{35}: Bestand niet gevonden.
\end{itemize}
Dit vereist een veel actievere en defensievere programmeerstijl dan junioren gewend zijn in Python, waar een \texttt{FileNotFoundError} automatisch de executie stopt met een duidelijke melding.

% TODO: OOP?

\section{Gamification}

TODO: fix intro en definitie
\textcite{Deterding2011} definiëren gamification als het gebruik van game-\allowbreak ontwerpelementen in niet-\allowbreak game contexten. 
\textcite{Deterding2011} leggen hun definitie uit en stellen dat gamification meer met "gamen" \textit{(ludus)} dan met "playing" \textit{(paidia)} te maken heeft, er zijn namelijk regels die moeten worden gevolgd.
Gamification  maakt  gebruik  van  elementen  uit  game-ontwerp,  maar  kan  niet  als  volwaardige  games  worden  beschouwd.

\subsection{Game-elementen}

Om gamification effectief toe te passen, worden specifieke bouwstenen uit games geïsoleerd en geïmplementeerd. 
Deze elementen fungeren als de brug tussen de systeemregels en de psychologische behoeften van de gebruiker. 
Volgens \textcite{KevinWerbach2020} kunnen deze elementen worden onderverdeeld in een hiërarchie van dynamieken, mechanieken en componenten. 
De componenten zijn de meest zichtbare uitingen hiervan, vaak samengevat onder de noemer PBL.

\subsubsection{Veelvoorkomende Game-elementen: PBL}

De meest bekende en toegepaste elementen binnen gamification staan bekend als de PBL-triade: \textit{Points}, \textit{Badges} en \textit{Leaderboards} \autocite{KevinWerbach2020}.

\begin{itemize}
    \item \textbf{Points (Punten):} In een gamified proces worden punten gebruikt om mensen aan te moedigen om dingen te doen door het verzamelen van punten te koppelen aan gewenste activiteiten. \autocite{KevinWerbach2020}
    \item \textbf{Badges (Badges/Trofeeën):} Badges zijn een uitgebreidere versie van punten. Een badge is een visuele weergave van een prestatie binnen het gamified proces. \autocite{KevinWerbach2020}
    \item \textbf{Leaderboards (Ranglijsten):} Volgens \textcite{KevinWerbach2020} zijn leaderboards zijn het meest problematische onderdeel van de PBL-triade. Hoewel ze motiveren door sociale vergelijking en zichtbare progressie, kunnen ze ook demotiveren wanneer de afstand tot de top te groot is. In zakelijke omgevingen leiden ze vaak tot ongewenst gedrag en verminderde prestaties, doordat de focus verschuift naar een destructieve competitie.
\end{itemize}

\subsubsection{Naast PBL}
Hoewel veel gamification-implementaties zich beperken tot de PBL-triade, is dit volgens \textcite{KevinWerbach2020} slechts het startpunt. 
Punten, badges en ranglijsten zijn populair omdat ze vertrouwd aanvoelen en eenvoudig te integreren zijn via bestaande software en bekende systemen, zoals loyaliteitsprogramma's.
Echter, wie de volledige waarde uit gamification wil halen, moet verder kijken dan deze drie elementen alleen.
Het blindelings vertrouwen op PBL's kan tot problemen leiden, omdat ze niet voor elk project de juiste oplossing bieden.
Om een systeem te ontwerpen dat werkelijk functioneert als een spel, is het essentieel om dieper in te gaan op de onderliggende spelmechanieken en dynamieken die een ervaring intrinsiek motiverend maken. \autocite{KevinWerbach2020}

\subsection{Frameworks}
Om gamification succesvol te implementeren, volstaat het niet om enkel losse spel-elementen aan een bestaand proces toe te voegen. 
Het risico van een dergelijke gefragmenteerde aanpak is de zogenaamde "PBL-fallacy": de misvatting dat de aanwezigheid van punten, badges en leaderboards automatisch leidt tot motivatie en betrokkenheid \autocite{KevinWerbach2020}.
Om dit te voorkomen, maken ontwerpers gebruik van theoretische frameworks.

Deze raamwerken bieden een gestructureerde methode om de interactie tussen de technische bouwstenen, de dynamiek van het systeem en de psychologische impact op de gebruiker te begrijpen. 
Waar sommige modellen zich concentreren op de formele systeemarchitectuur, leggen andere de nadruk op de menselijke motivatie. 
In dit onderdeel worden twee toonaangevende benaderingen besproken: het technisch georiënteerde MDA-framework en het op psychologie gebaseerde Octalysis-model.

\subsubsection{MDA-framework}
Het MDA-framework, een acroniem voor \textit{Mechanics}, \textit{Dynamics}, en \textit{Aesthetics}, is een formele methode die tracht de kloof tussen game-ontwerp, game-kritiek en technisch onderzoek te overbruggen \autocite{Hunicke2004}.
In tegenstelling tot passieve media zoals film of literatuur, wordt de inhoud van een game gedefinieerd door het interactieve gedrag van het systeem. 
\textcite{Hunicke2004} stellen dat games begrepen moeten worden als systemen die ervaringen opbouwen via drie hiërarchische niveaus:

\begin{itemize}
    \item \textbf{Mechanics (Mechanieken):} Dit zijn de fundamentele bouwstenen van de game op het niveau van data en algoritmen. 
    Het omvat de regels, de fysica van de gamewereld en de specifieke acties die een speler kan uitvoeren (zoals springen, punten verdienen of een tijdslimiet). 
    In een zakelijke gamification-context zijn dit bijvoorbeeld de algoritmen die bepalen wanneer een gebruiker een badge ontvangt. \autocite{Hunicke2004}.

    \item \textbf{Dynamics (Dynamiek):} Dit beschrijft het \textit{run-time} gedrag van de mechanieken wanneer ze in werking treden door interactie van de speler. 
    Dynamics ontstaan wanneer verschillende mechanics op elkaar inwerken. 
    Een tijdslimiet (mechanic) gecombineerd met een ranglijst (mechanic) creëert bijvoorbeeld een gevoel van tijdsdruk en competitie (dynamics). 
    Dit is het niveau waarop strategieën en speelstijlen van gebruikers zichtbaar worden. \autocite{Hunicke2004}

    \item \textbf{Aesthetics (Esthetiek):} Dit verwijst niet naar het visuele aspect, maar naar de \textit{emotionele reactie} die bij de speler wordt opgeroepen. 
    Het gaat om de "ervaring van plezier". 
    \textcite{Hunicke2004} categoriseren dit verder in vormen zoals \textit{Sensation} (zintuiglijk genot), \textit{Fantasy} (onderdompeling in een andere wereld), \textit{Narrative} (het verhaal) en \textit{Challenge} (de voldoening van het overwinnen van hindernissen).
\end{itemize}

Een cruciaal inzicht van dit raamwerk is de omgekeerde causaliteit tussen de ontwerper en de speler. 
Er bestaat een lineair maar tegengesteld perspectief: \autocite{Hunicke2004}

\begin{enumerate}
    \item \textbf{Het perspectief van de ontwerper (Top-down):} De ontwerper vertrekt vanuit de \textit{Mechanics}. 
    Door regels en systemen te bouwen, hoopt de ontwerper dat er een bepaalde \textit{Dynamics} ontstaat die uiteindelijk leidt tot de gewenste \textit{Aesthetics} (de emotionele ervaring).
    \item \textbf{Het perspectief van de speler (Bottom-up):} De speler ervaart de game in omgekeerde volgorde. 
    De eerste kennismaking is de \textit{Aesthetics}. 
    Pas door te spelen ontdekt de speler de \textit{Dynamics}, en pas na verloop van tijd begrijpt hij de onderliggende \textit{Mechanics} die alles aansturen.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{MDA.png}
    \caption{Perspectief van Speler en Designer binnen het MDA-Framework \autocite{Hunicke2004}}
    \label{fig:mda}
\end{figure}

Door deze gelaagdheid te erkennen, kunnen ontwikkelaars voorkomen dat ze louter "functiegericht" ontwerpen. 
Het MDA-framework dwingt de ontwerper om na te denken over hoe een kleine wijziging in de code (Mechanics) de volledige emotionele beleving (Aesthetics) van de eindgebruiker kan beïnvloeden. \autocite{Hunicke2004}

\subsubsection{Octalysis-framework} % TODO
Een ander populair framework dat specifiek kijkt naar de psychologische drijfveren achter deze gamedesign-\allowbreak elementen: het \textit{Octalysis-\allowbreak framework}, ontwikkeld door \textcite{Chou2015}. 
Waar de definitie van \textcite{Deterding2011} zich sterk richt op de classificatie van elementen, vertrekt Chou vanuit het principe van \textit{Human-Focused Design}.
Dit houdt in dat het ontwerp niet primair draait om de functionele elementen (zoals badges of leaderboards), maar om de manier waarop deze elementen inspelen op de menselijke motivatie en emoties.
Het framework is opgebouwd rond acht fundamentele motivaties, de \textit{Core Drives}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{octalysis.jpg}
    \caption{Octalysis Framework \autocite{Chou2015}}
    \label{fig:octalysis}
\end{figure}


% =======================================================
\subsubsection{Gamification bij junior developers} %TODO

Een meta-analyse studie van \textcite{Zhan2022} toont ook aan dat gamification een positieve impact heeft op het onderwijs in programmeren. 
Gamification had met name het grootste effect op de motivatie en academische prestaties van studenten, gevolgd door het denkvermogen.


\subsection{hoe Effectiviteit meten} %TODO